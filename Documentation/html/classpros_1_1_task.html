<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robotics team coding repo: pros::Task Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Robotics team coding repo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pros</b></li><li class="navelem"><a class="el" href="classpros_1_1_task.html">Task</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classpros_1_1_task-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pros::Task Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2e94f57e088ff9b56b78b5d1d7cb2169">Task</a> (task_fn_t function, void *parameters=nullptr, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64608b28832c40cf11ddb350a7331a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a64608b28832c40cf11ddb350a7331a08">Task</a> (task_fn_t function, void *parameters, const char *name)</td></tr>
<tr class="separator:a64608b28832c40cf11ddb350a7331a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a6574af1a29f3031904fc75bf67563c00">Task</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a6574af1a29f3031904fc75bf67563c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ada7a776e565ab35ebe4737747cca9926">Task</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ada7a776e565ab35ebe4737747cca9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37b46942f1ba25513729b15a32e12f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0b37b46942f1ba25513729b15a32e12f">Task</a> (task_t task)</td></tr>
<tr class="separator:a0b37b46942f1ba25513729b15a32e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e70532f42a21702d925c95d7432590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpros_1_1_task.html">Task</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a95e70532f42a21702d925c95d7432590">operator=</a> (task_t in)</td></tr>
<tr class="separator:a95e70532f42a21702d925c95d7432590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45269807dfc87bb1d5e9580346793e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a45269807dfc87bb1d5e9580346793e9d">remove</a> ()</td></tr>
<tr class="separator:a45269807dfc87bb1d5e9580346793e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2a9dc12bb0799f8b18333ebcd7571e5b">get_priority</a> ()</td></tr>
<tr class="separator:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a9937d34311ba10f540bc58d0b0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a205a9937d34311ba10f540bc58d0b0b9">set_priority</a> (std::uint32_t prio)</td></tr>
<tr class="separator:a205a9937d34311ba10f540bc58d0b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c154b709095c4884d325d79a839e3"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0e1c154b709095c4884d325d79a839e3">get_state</a> ()</td></tr>
<tr class="separator:a0e1c154b709095c4884d325d79a839e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d452a967a2bd839f6e819ff26ff052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a07d452a967a2bd839f6e819ff26ff052">suspend</a> ()</td></tr>
<tr class="separator:a07d452a967a2bd839f6e819ff26ff052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#abb8b8aa01d13ba3992953d0a7d668a47">resume</a> ()</td></tr>
<tr class="separator:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8521f655ff019d11caddb513afbb50e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa8521f655ff019d11caddb513afbb50e">get_name</a> ()</td></tr>
<tr class="separator:aa8521f655ff019d11caddb513afbb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c15efcec74a76b6848fc999ff0c232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a16c15efcec74a76b6848fc999ff0c232">operator task_t</a> ()</td></tr>
<tr class="separator:a16c15efcec74a76b6848fc999ff0c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce264851745a555bb141884a1a61ab"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af7ce264851745a555bb141884a1a61ab">notify</a> ()</td></tr>
<tr class="separator:af7ce264851745a555bb141884a1a61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250c6e369dd2621a8b31d7ed085f819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af250c6e369dd2621a8b31d7ed085f819">join</a> ()</td></tr>
<tr class="separator:af250c6e369dd2621a8b31d7ed085f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#add5bc6272aaa903fdf8ae6656d8ffddb">notify_ext</a> (std::uint32_t value, notify_action_e_t action, std::uint32_t *prev_value)</td></tr>
<tr class="separator:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a69c4d78a733f65cff31d7ab19d3f42f5">notify_clear</a> ()</td></tr>
<tr class="separator:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2e94f57e088ff9b56b78b5d1d7cb2169">Task</a> (task_fn_t function, void *parameters=nullptr, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64608b28832c40cf11ddb350a7331a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a64608b28832c40cf11ddb350a7331a08">Task</a> (task_fn_t function, void *parameters, const char *name)</td></tr>
<tr class="separator:a64608b28832c40cf11ddb350a7331a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a6574af1a29f3031904fc75bf67563c00">Task</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a6574af1a29f3031904fc75bf67563c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ada7a776e565ab35ebe4737747cca9926">Task</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ada7a776e565ab35ebe4737747cca9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37b46942f1ba25513729b15a32e12f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0b37b46942f1ba25513729b15a32e12f">Task</a> (task_t task)</td></tr>
<tr class="separator:a0b37b46942f1ba25513729b15a32e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e70532f42a21702d925c95d7432590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpros_1_1_task.html">Task</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a95e70532f42a21702d925c95d7432590">operator=</a> (task_t in)</td></tr>
<tr class="separator:a95e70532f42a21702d925c95d7432590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45269807dfc87bb1d5e9580346793e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a45269807dfc87bb1d5e9580346793e9d">remove</a> ()</td></tr>
<tr class="separator:a45269807dfc87bb1d5e9580346793e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2a9dc12bb0799f8b18333ebcd7571e5b">get_priority</a> ()</td></tr>
<tr class="separator:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a9937d34311ba10f540bc58d0b0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a205a9937d34311ba10f540bc58d0b0b9">set_priority</a> (std::uint32_t prio)</td></tr>
<tr class="separator:a205a9937d34311ba10f540bc58d0b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c154b709095c4884d325d79a839e3"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0e1c154b709095c4884d325d79a839e3">get_state</a> ()</td></tr>
<tr class="separator:a0e1c154b709095c4884d325d79a839e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d452a967a2bd839f6e819ff26ff052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a07d452a967a2bd839f6e819ff26ff052">suspend</a> ()</td></tr>
<tr class="separator:a07d452a967a2bd839f6e819ff26ff052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#abb8b8aa01d13ba3992953d0a7d668a47">resume</a> ()</td></tr>
<tr class="separator:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8521f655ff019d11caddb513afbb50e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa8521f655ff019d11caddb513afbb50e">get_name</a> ()</td></tr>
<tr class="separator:aa8521f655ff019d11caddb513afbb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c15efcec74a76b6848fc999ff0c232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a16c15efcec74a76b6848fc999ff0c232">operator task_t</a> ()</td></tr>
<tr class="separator:a16c15efcec74a76b6848fc999ff0c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce264851745a555bb141884a1a61ab"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af7ce264851745a555bb141884a1a61ab">notify</a> ()</td></tr>
<tr class="separator:af7ce264851745a555bb141884a1a61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250c6e369dd2621a8b31d7ed085f819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af250c6e369dd2621a8b31d7ed085f819">join</a> ()</td></tr>
<tr class="separator:af250c6e369dd2621a8b31d7ed085f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#add5bc6272aaa903fdf8ae6656d8ffddb">notify_ext</a> (std::uint32_t value, notify_action_e_t action, std::uint32_t *prev_value)</td></tr>
<tr class="separator:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a69c4d78a733f65cff31d7ab19d3f42f5">notify_clear</a> ()</td></tr>
<tr class="separator:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2e94f57e088ff9b56b78b5d1d7cb2169">Task</a> (task_fn_t function, void *parameters=nullptr, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64608b28832c40cf11ddb350a7331a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a64608b28832c40cf11ddb350a7331a08">Task</a> (task_fn_t function, void *parameters, const char *name)</td></tr>
<tr class="separator:a64608b28832c40cf11ddb350a7331a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a6574af1a29f3031904fc75bf67563c00">Task</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a6574af1a29f3031904fc75bf67563c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ada7a776e565ab35ebe4737747cca9926">Task</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ada7a776e565ab35ebe4737747cca9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37b46942f1ba25513729b15a32e12f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0b37b46942f1ba25513729b15a32e12f">Task</a> (task_t task)</td></tr>
<tr class="separator:a0b37b46942f1ba25513729b15a32e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e70532f42a21702d925c95d7432590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpros_1_1_task.html">Task</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a95e70532f42a21702d925c95d7432590">operator=</a> (task_t in)</td></tr>
<tr class="separator:a95e70532f42a21702d925c95d7432590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45269807dfc87bb1d5e9580346793e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a45269807dfc87bb1d5e9580346793e9d">remove</a> ()</td></tr>
<tr class="separator:a45269807dfc87bb1d5e9580346793e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2a9dc12bb0799f8b18333ebcd7571e5b">get_priority</a> ()</td></tr>
<tr class="separator:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a9937d34311ba10f540bc58d0b0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a205a9937d34311ba10f540bc58d0b0b9">set_priority</a> (std::uint32_t prio)</td></tr>
<tr class="separator:a205a9937d34311ba10f540bc58d0b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c154b709095c4884d325d79a839e3"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0e1c154b709095c4884d325d79a839e3">get_state</a> ()</td></tr>
<tr class="separator:a0e1c154b709095c4884d325d79a839e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d452a967a2bd839f6e819ff26ff052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a07d452a967a2bd839f6e819ff26ff052">suspend</a> ()</td></tr>
<tr class="separator:a07d452a967a2bd839f6e819ff26ff052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#abb8b8aa01d13ba3992953d0a7d668a47">resume</a> ()</td></tr>
<tr class="separator:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8521f655ff019d11caddb513afbb50e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa8521f655ff019d11caddb513afbb50e">get_name</a> ()</td></tr>
<tr class="separator:aa8521f655ff019d11caddb513afbb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c15efcec74a76b6848fc999ff0c232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a16c15efcec74a76b6848fc999ff0c232">operator task_t</a> ()</td></tr>
<tr class="separator:a16c15efcec74a76b6848fc999ff0c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce264851745a555bb141884a1a61ab"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af7ce264851745a555bb141884a1a61ab">notify</a> ()</td></tr>
<tr class="separator:af7ce264851745a555bb141884a1a61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250c6e369dd2621a8b31d7ed085f819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af250c6e369dd2621a8b31d7ed085f819">join</a> ()</td></tr>
<tr class="separator:af250c6e369dd2621a8b31d7ed085f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#add5bc6272aaa903fdf8ae6656d8ffddb">notify_ext</a> (std::uint32_t value, notify_action_e_t action, std::uint32_t *prev_value)</td></tr>
<tr class="separator:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a69c4d78a733f65cff31d7ab19d3f42f5">notify_clear</a> ()</td></tr>
<tr class="separator:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2e94f57e088ff9b56b78b5d1d7cb2169">Task</a> (task_fn_t function, void *parameters=nullptr, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64608b28832c40cf11ddb350a7331a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a64608b28832c40cf11ddb350a7331a08">Task</a> (task_fn_t function, void *parameters, const char *name)</td></tr>
<tr class="separator:a64608b28832c40cf11ddb350a7331a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a6574af1a29f3031904fc75bf67563c00">Task</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a6574af1a29f3031904fc75bf67563c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ada7a776e565ab35ebe4737747cca9926">Task</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ada7a776e565ab35ebe4737747cca9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37b46942f1ba25513729b15a32e12f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0b37b46942f1ba25513729b15a32e12f">Task</a> (task_t task)</td></tr>
<tr class="separator:a0b37b46942f1ba25513729b15a32e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e70532f42a21702d925c95d7432590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpros_1_1_task.html">Task</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a95e70532f42a21702d925c95d7432590">operator=</a> (task_t in)</td></tr>
<tr class="separator:a95e70532f42a21702d925c95d7432590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45269807dfc87bb1d5e9580346793e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a45269807dfc87bb1d5e9580346793e9d">remove</a> ()</td></tr>
<tr class="separator:a45269807dfc87bb1d5e9580346793e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2a9dc12bb0799f8b18333ebcd7571e5b">get_priority</a> ()</td></tr>
<tr class="separator:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a9937d34311ba10f540bc58d0b0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a205a9937d34311ba10f540bc58d0b0b9">set_priority</a> (std::uint32_t prio)</td></tr>
<tr class="separator:a205a9937d34311ba10f540bc58d0b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c154b709095c4884d325d79a839e3"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0e1c154b709095c4884d325d79a839e3">get_state</a> ()</td></tr>
<tr class="separator:a0e1c154b709095c4884d325d79a839e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d452a967a2bd839f6e819ff26ff052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a07d452a967a2bd839f6e819ff26ff052">suspend</a> ()</td></tr>
<tr class="separator:a07d452a967a2bd839f6e819ff26ff052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#abb8b8aa01d13ba3992953d0a7d668a47">resume</a> ()</td></tr>
<tr class="separator:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8521f655ff019d11caddb513afbb50e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa8521f655ff019d11caddb513afbb50e">get_name</a> ()</td></tr>
<tr class="separator:aa8521f655ff019d11caddb513afbb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c15efcec74a76b6848fc999ff0c232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a16c15efcec74a76b6848fc999ff0c232">operator task_t</a> ()</td></tr>
<tr class="separator:a16c15efcec74a76b6848fc999ff0c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce264851745a555bb141884a1a61ab"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af7ce264851745a555bb141884a1a61ab">notify</a> ()</td></tr>
<tr class="separator:af7ce264851745a555bb141884a1a61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250c6e369dd2621a8b31d7ed085f819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af250c6e369dd2621a8b31d7ed085f819">join</a> ()</td></tr>
<tr class="separator:af250c6e369dd2621a8b31d7ed085f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#add5bc6272aaa903fdf8ae6656d8ffddb">notify_ext</a> (std::uint32_t value, notify_action_e_t action, std::uint32_t *prev_value)</td></tr>
<tr class="separator:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a69c4d78a733f65cff31d7ab19d3f42f5">notify_clear</a> ()</td></tr>
<tr class="separator:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2e94f57e088ff9b56b78b5d1d7cb2169">Task</a> (task_fn_t function, void *parameters=nullptr, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a2e94f57e088ff9b56b78b5d1d7cb2169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64608b28832c40cf11ddb350a7331a08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a64608b28832c40cf11ddb350a7331a08">Task</a> (task_fn_t function, void *parameters, const char *name)</td></tr>
<tr class="separator:a64608b28832c40cf11ddb350a7331a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a6574af1a29f3031904fc75bf67563c00"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a6574af1a29f3031904fc75bf67563c00">Task</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a6574af1a29f3031904fc75bf67563c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ada7a776e565ab35ebe4737747cca9926"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ada7a776e565ab35ebe4737747cca9926">Task</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ada7a776e565ab35ebe4737747cca9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b37b46942f1ba25513729b15a32e12f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0b37b46942f1ba25513729b15a32e12f">Task</a> (task_t task)</td></tr>
<tr class="separator:a0b37b46942f1ba25513729b15a32e12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e70532f42a21702d925c95d7432590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpros_1_1_task.html">Task</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a95e70532f42a21702d925c95d7432590">operator=</a> (task_t in)</td></tr>
<tr class="separator:a95e70532f42a21702d925c95d7432590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45269807dfc87bb1d5e9580346793e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a45269807dfc87bb1d5e9580346793e9d">remove</a> ()</td></tr>
<tr class="separator:a45269807dfc87bb1d5e9580346793e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a2a9dc12bb0799f8b18333ebcd7571e5b">get_priority</a> ()</td></tr>
<tr class="separator:a2a9dc12bb0799f8b18333ebcd7571e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a205a9937d34311ba10f540bc58d0b0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a205a9937d34311ba10f540bc58d0b0b9">set_priority</a> (std::uint32_t prio)</td></tr>
<tr class="separator:a205a9937d34311ba10f540bc58d0b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1c154b709095c4884d325d79a839e3"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a0e1c154b709095c4884d325d79a839e3">get_state</a> ()</td></tr>
<tr class="separator:a0e1c154b709095c4884d325d79a839e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d452a967a2bd839f6e819ff26ff052"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a07d452a967a2bd839f6e819ff26ff052">suspend</a> ()</td></tr>
<tr class="separator:a07d452a967a2bd839f6e819ff26ff052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#abb8b8aa01d13ba3992953d0a7d668a47">resume</a> ()</td></tr>
<tr class="separator:abb8b8aa01d13ba3992953d0a7d668a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8521f655ff019d11caddb513afbb50e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa8521f655ff019d11caddb513afbb50e">get_name</a> ()</td></tr>
<tr class="separator:aa8521f655ff019d11caddb513afbb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c15efcec74a76b6848fc999ff0c232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a16c15efcec74a76b6848fc999ff0c232">operator task_t</a> ()</td></tr>
<tr class="separator:a16c15efcec74a76b6848fc999ff0c232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce264851745a555bb141884a1a61ab"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af7ce264851745a555bb141884a1a61ab">notify</a> ()</td></tr>
<tr class="separator:af7ce264851745a555bb141884a1a61ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af250c6e369dd2621a8b31d7ed085f819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#af250c6e369dd2621a8b31d7ed085f819">join</a> ()</td></tr>
<tr class="separator:af250c6e369dd2621a8b31d7ed085f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#add5bc6272aaa903fdf8ae6656d8ffddb">notify_ext</a> (std::uint32_t value, notify_action_e_t action, std::uint32_t *prev_value)</td></tr>
<tr class="separator:add5bc6272aaa903fdf8ae6656d8ffddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a69c4d78a733f65cff31d7ab19d3f42f5">notify_clear</a> ()</td></tr>
<tr class="separator:a69c4d78a733f65cff31d7ab19d3f42f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">create</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ab328832af79235e2799b244ee53d3911">create</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ab328832af79235e2799b244ee53d3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ca3e67e54aa4293438d73148a1d6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpros_1_1_task.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a510ca3e67e54aa4293438d73148a1d6b">current</a> ()</td></tr>
<tr class="separator:a510ca3e67e54aa4293438d73148a1d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a7a7d29a221c08cda730ca9eb8c026a12">notify_take</a> (bool clear_on_exit, std::uint32_t timeout)</td></tr>
<tr class="separator:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341b580544831eea11b840cf068587b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a4341b580544831eea11b840cf068587b">delay</a> (const std::uint32_t milliseconds)</td></tr>
<tr class="separator:a4341b580544831eea11b840cf068587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa038d0eeb973ce7fca8689fa5bb91fec">delay_until</a> (std::uint32_t *const prev_time, const std::uint32_t delta)</td></tr>
<tr class="separator:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace43489ca71bdd884e4518700a4bbe58"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ace43489ca71bdd884e4518700a4bbe58">get_count</a> ()</td></tr>
<tr class="separator:ace43489ca71bdd884e4518700a4bbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">create</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ab328832af79235e2799b244ee53d3911">create</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ab328832af79235e2799b244ee53d3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ca3e67e54aa4293438d73148a1d6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpros_1_1_task.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a510ca3e67e54aa4293438d73148a1d6b">current</a> ()</td></tr>
<tr class="separator:a510ca3e67e54aa4293438d73148a1d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a7a7d29a221c08cda730ca9eb8c026a12">notify_take</a> (bool clear_on_exit, std::uint32_t timeout)</td></tr>
<tr class="separator:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341b580544831eea11b840cf068587b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a4341b580544831eea11b840cf068587b">delay</a> (const std::uint32_t milliseconds)</td></tr>
<tr class="separator:a4341b580544831eea11b840cf068587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa038d0eeb973ce7fca8689fa5bb91fec">delay_until</a> (std::uint32_t *const prev_time, const std::uint32_t delta)</td></tr>
<tr class="separator:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace43489ca71bdd884e4518700a4bbe58"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ace43489ca71bdd884e4518700a4bbe58">get_count</a> ()</td></tr>
<tr class="separator:ace43489ca71bdd884e4518700a4bbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">create</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ab328832af79235e2799b244ee53d3911">create</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ab328832af79235e2799b244ee53d3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ca3e67e54aa4293438d73148a1d6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpros_1_1_task.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a510ca3e67e54aa4293438d73148a1d6b">current</a> ()</td></tr>
<tr class="separator:a510ca3e67e54aa4293438d73148a1d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a7a7d29a221c08cda730ca9eb8c026a12">notify_take</a> (bool clear_on_exit, std::uint32_t timeout)</td></tr>
<tr class="separator:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341b580544831eea11b840cf068587b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a4341b580544831eea11b840cf068587b">delay</a> (const std::uint32_t milliseconds)</td></tr>
<tr class="separator:a4341b580544831eea11b840cf068587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa038d0eeb973ce7fca8689fa5bb91fec">delay_until</a> (std::uint32_t *const prev_time, const std::uint32_t delta)</td></tr>
<tr class="separator:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace43489ca71bdd884e4518700a4bbe58"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ace43489ca71bdd884e4518700a4bbe58">get_count</a> ()</td></tr>
<tr class="separator:ace43489ca71bdd884e4518700a4bbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">create</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ab328832af79235e2799b244ee53d3911">create</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ab328832af79235e2799b244ee53d3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ca3e67e54aa4293438d73148a1d6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpros_1_1_task.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a510ca3e67e54aa4293438d73148a1d6b">current</a> ()</td></tr>
<tr class="separator:a510ca3e67e54aa4293438d73148a1d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a7a7d29a221c08cda730ca9eb8c026a12">notify_take</a> (bool clear_on_exit, std::uint32_t timeout)</td></tr>
<tr class="separator:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341b580544831eea11b840cf068587b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a4341b580544831eea11b840cf068587b">delay</a> (const std::uint32_t milliseconds)</td></tr>
<tr class="separator:a4341b580544831eea11b840cf068587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa038d0eeb973ce7fca8689fa5bb91fec">delay_until</a> (std::uint32_t *const prev_time, const std::uint32_t delta)</td></tr>
<tr class="separator:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace43489ca71bdd884e4518700a4bbe58"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ace43489ca71bdd884e4518700a4bbe58">get_count</a> ()</td></tr>
<tr class="separator:ace43489ca71bdd884e4518700a4bbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">create</a> (F &amp;&amp;function, std::uint32_t prio=TASK_PRIORITY_DEFAULT, std::uint16_t stack_depth=TASK_STACK_DEPTH_DEFAULT, const char *name=&quot;&quot;)</td></tr>
<tr class="separator:a9cb4b14a7a47b4aea4d8e71ae3bd4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplParams" colspan="2">template&lt;class F &gt; </td></tr>
<tr class="memitem:ab328832af79235e2799b244ee53d3911"><td class="memTemplItemLeft" align="right" valign="top">static task_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ab328832af79235e2799b244ee53d3911">create</a> (F &amp;&amp;function, const char *name)</td></tr>
<tr class="separator:ab328832af79235e2799b244ee53d3911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510ca3e67e54aa4293438d73148a1d6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classpros_1_1_task.html">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a510ca3e67e54aa4293438d73148a1d6b">current</a> ()</td></tr>
<tr class="separator:a510ca3e67e54aa4293438d73148a1d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a7a7d29a221c08cda730ca9eb8c026a12">notify_take</a> (bool clear_on_exit, std::uint32_t timeout)</td></tr>
<tr class="separator:a7a7d29a221c08cda730ca9eb8c026a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341b580544831eea11b840cf068587b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#a4341b580544831eea11b840cf068587b">delay</a> (const std::uint32_t milliseconds)</td></tr>
<tr class="separator:a4341b580544831eea11b840cf068587b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#aa038d0eeb973ce7fca8689fa5bb91fec">delay_until</a> (std::uint32_t *const prev_time, const std::uint32_t delta)</td></tr>
<tr class="separator:aa038d0eeb973ce7fca8689fa5bb91fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace43489ca71bdd884e4518700a4bbe58"><td class="memItemLeft" align="right" valign="top">static std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_task.html#ace43489ca71bdd884e4518700a4bbe58">get_count</a> ()</td></tr>
<tr class="separator:ace43489ca71bdd884e4518700a4bbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2e94f57e088ff9b56b78b5d1d7cb2169" name="a2e94f57e088ff9b56b78b5d1d7cb2169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94f57e088ff9b56b78b5d1d7cb2169">&#9670;&#160;</a></span>Task() <span class="overload">[1/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64608b28832c40cf11ddb350a7331a08" name="a64608b28832c40cf11ddb350a7331a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64608b28832c40cf11ddb350a7331a08">&#9670;&#160;</a></span>Task() <span class="overload">[2/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6574af1a29f3031904fc75bf67563c00" name="a6574af1a29f3031904fc75bf67563c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574af1a29f3031904fc75bf67563c00">&#9670;&#160;</a></span>Task() <span class="overload">[3/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7a776e565ab35ebe4737747cca9926" name="ada7a776e565ab35ebe4737747cca9926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7a776e565ab35ebe4737747cca9926">&#9670;&#160;</a></span>Task() <span class="overload">[4/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b37b46942f1ba25513729b15a32e12f" name="a0b37b46942f1ba25513729b15a32e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37b46942f1ba25513729b15a32e12f">&#9670;&#160;</a></span>Task() <span class="overload">[5/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a C++ task object from a task handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e94f57e088ff9b56b78b5d1d7cb2169" name="a2e94f57e088ff9b56b78b5d1d7cb2169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94f57e088ff9b56b78b5d1d7cb2169">&#9670;&#160;</a></span>Task() <span class="overload">[6/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64608b28832c40cf11ddb350a7331a08" name="a64608b28832c40cf11ddb350a7331a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64608b28832c40cf11ddb350a7331a08">&#9670;&#160;</a></span>Task() <span class="overload">[7/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6574af1a29f3031904fc75bf67563c00" name="a6574af1a29f3031904fc75bf67563c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574af1a29f3031904fc75bf67563c00">&#9670;&#160;</a></span>Task() <span class="overload">[8/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7a776e565ab35ebe4737747cca9926" name="ada7a776e565ab35ebe4737747cca9926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7a776e565ab35ebe4737747cca9926">&#9670;&#160;</a></span>Task() <span class="overload">[9/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b37b46942f1ba25513729b15a32e12f" name="a0b37b46942f1ba25513729b15a32e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37b46942f1ba25513729b15a32e12f">&#9670;&#160;</a></span>Task() <span class="overload">[10/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a C++ task object from a task handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e94f57e088ff9b56b78b5d1d7cb2169" name="a2e94f57e088ff9b56b78b5d1d7cb2169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94f57e088ff9b56b78b5d1d7cb2169">&#9670;&#160;</a></span>Task() <span class="overload">[11/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64608b28832c40cf11ddb350a7331a08" name="a64608b28832c40cf11ddb350a7331a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64608b28832c40cf11ddb350a7331a08">&#9670;&#160;</a></span>Task() <span class="overload">[12/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6574af1a29f3031904fc75bf67563c00" name="a6574af1a29f3031904fc75bf67563c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574af1a29f3031904fc75bf67563c00">&#9670;&#160;</a></span>Task() <span class="overload">[13/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7a776e565ab35ebe4737747cca9926" name="ada7a776e565ab35ebe4737747cca9926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7a776e565ab35ebe4737747cca9926">&#9670;&#160;</a></span>Task() <span class="overload">[14/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b37b46942f1ba25513729b15a32e12f" name="a0b37b46942f1ba25513729b15a32e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37b46942f1ba25513729b15a32e12f">&#9670;&#160;</a></span>Task() <span class="overload">[15/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a C++ task object from a task handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e94f57e088ff9b56b78b5d1d7cb2169" name="a2e94f57e088ff9b56b78b5d1d7cb2169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94f57e088ff9b56b78b5d1d7cb2169">&#9670;&#160;</a></span>Task() <span class="overload">[16/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64608b28832c40cf11ddb350a7331a08" name="a64608b28832c40cf11ddb350a7331a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64608b28832c40cf11ddb350a7331a08">&#9670;&#160;</a></span>Task() <span class="overload">[17/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6574af1a29f3031904fc75bf67563c00" name="a6574af1a29f3031904fc75bf67563c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574af1a29f3031904fc75bf67563c00">&#9670;&#160;</a></span>Task() <span class="overload">[18/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7a776e565ab35ebe4737747cca9926" name="ada7a776e565ab35ebe4737747cca9926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7a776e565ab35ebe4737747cca9926">&#9670;&#160;</a></span>Task() <span class="overload">[19/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b37b46942f1ba25513729b15a32e12f" name="a0b37b46942f1ba25513729b15a32e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37b46942f1ba25513729b15a32e12f">&#9670;&#160;</a></span>Task() <span class="overload">[20/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a C++ task object from a task handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e94f57e088ff9b56b78b5d1d7cb2169" name="a2e94f57e088ff9b56b78b5d1d7cb2169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e94f57e088ff9b56b78b5d1d7cb2169">&#9670;&#160;</a></span>Task() <span class="overload">[21/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64608b28832c40cf11ddb350a7331a08" name="a64608b28832c40cf11ddb350a7331a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64608b28832c40cf11ddb350a7331a08">&#9670;&#160;</a></span>Task() <span class="overload">[22/25]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_fn_t&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Pointer to the task entry function </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to memory that will be used as a parameter for the task being created. This memory should not typically come from stack, but rather from dynamically (i.e., malloc'd) or statically allocated memory. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6574af1a29f3031904fc75bf67563c00" name="a6574af1a29f3031904fc75bf67563c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574af1a29f3031904fc75bf67563c00">&#9670;&#160;</a></span>Task() <span class="overload">[23/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada7a776e565ab35ebe4737747cca9926" name="ada7a776e565ab35ebe4737747cca9926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7a776e565ab35ebe4737747cca9926">&#9670;&#160;</a></span>Task() <span class="overload">[24/25]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b37b46942f1ba25513729b15a32e12f" name="a0b37b46942f1ba25513729b15a32e12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b37b46942f1ba25513729b15a32e12f">&#9670;&#160;</a></span>Task() <span class="overload">[25/25]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::Task </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Create a C++ task object from a task handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab328832af79235e2799b244ee53d3911" name="ab328832af79235e2799b244ee53d3911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328832af79235e2799b244ee53d3911">&#9670;&#160;</a></span>create() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab328832af79235e2799b244ee53d3911" name="ab328832af79235e2799b244ee53d3911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328832af79235e2799b244ee53d3911">&#9670;&#160;</a></span>create() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab328832af79235e2799b244ee53d3911" name="ab328832af79235e2799b244ee53d3911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328832af79235e2799b244ee53d3911">&#9670;&#160;</a></span>create() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab328832af79235e2799b244ee53d3911" name="ab328832af79235e2799b244ee53d3911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328832af79235e2799b244ee53d3911">&#9670;&#160;</a></span>create() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab328832af79235e2799b244ee53d3911" name="ab328832af79235e2799b244ee53d3911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab328832af79235e2799b244ee53d3911">&#9670;&#160;</a></span>create() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb4b14a7a47b4aea4d8e71ae3bd4db2" name="a9cb4b14a7a47b4aea4d8e71ae3bd4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">&#9670;&#160;</a></span>create() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb4b14a7a47b4aea4d8e71ae3bd4db2" name="a9cb4b14a7a47b4aea4d8e71ae3bd4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">&#9670;&#160;</a></span>create() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb4b14a7a47b4aea4d8e71ae3bd4db2" name="a9cb4b14a7a47b4aea4d8e71ae3bd4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">&#9670;&#160;</a></span>create() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb4b14a7a47b4aea4d8e71ae3bd4db2" name="a9cb4b14a7a47b4aea4d8e71ae3bd4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">&#9670;&#160;</a></span>create() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb4b14a7a47b4aea4d8e71ae3bd4db2" name="a9cb4b14a7a47b4aea4d8e71ae3bd4db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb4b14a7a47b4aea4d8e71ae3bd4db2">&#9670;&#160;</a></span>create() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static task_t pros::Task::create </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em> = <code>TASK_PRIORITY_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>stack_depth</em> = <code>TASK_STACK_DEPTH_DEFAULT</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<p >This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Callable object to use as entry function </td></tr>
    <tr><td class="paramname">prio</td><td>The priority at which the task should run. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used. </td></tr>
    <tr><td class="paramname">stack_depth</td><td>The number of words (i.e. 4 * stack_depth) available on the task's stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct. </td></tr>
    <tr><td class="paramname">name</td><td>A descriptive name for the task. This is mainly used to facilitate debugging. The name may be up to 32 characters long. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a510ca3e67e54aa4293438d73148a1d6b" name="a510ca3e67e54aa4293438d73148a1d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ca3e67e54aa4293438d73148a1d6b">&#9670;&#160;</a></span>current() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpros_1_1_task.html">Task</a> pros::Task::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the currently running <a class="el" href="classpros_1_1_task.html">Task</a> </p>

</div>
</div>
<a id="a510ca3e67e54aa4293438d73148a1d6b" name="a510ca3e67e54aa4293438d73148a1d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ca3e67e54aa4293438d73148a1d6b">&#9670;&#160;</a></span>current() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpros_1_1_task.html">Task</a> pros::Task::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the currently running <a class="el" href="classpros_1_1_task.html">Task</a> </p>

</div>
</div>
<a id="a510ca3e67e54aa4293438d73148a1d6b" name="a510ca3e67e54aa4293438d73148a1d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ca3e67e54aa4293438d73148a1d6b">&#9670;&#160;</a></span>current() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpros_1_1_task.html">Task</a> pros::Task::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the currently running <a class="el" href="classpros_1_1_task.html">Task</a> </p>

</div>
</div>
<a id="a510ca3e67e54aa4293438d73148a1d6b" name="a510ca3e67e54aa4293438d73148a1d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ca3e67e54aa4293438d73148a1d6b">&#9670;&#160;</a></span>current() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpros_1_1_task.html">Task</a> pros::Task::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the currently running <a class="el" href="classpros_1_1_task.html">Task</a> </p>

</div>
</div>
<a id="a510ca3e67e54aa4293438d73148a1d6b" name="a510ca3e67e54aa4293438d73148a1d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510ca3e67e54aa4293438d73148a1d6b">&#9670;&#160;</a></span>current() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classpros_1_1_task.html">Task</a> pros::Task::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the currently running <a class="el" href="classpros_1_1_task.html">Task</a> </p>

</div>
</div>
<a id="a4341b580544831eea11b840cf068587b" name="a4341b580544831eea11b840cf068587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4341b580544831eea11b840cf068587b">&#9670;&#160;</a></span>delay() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay </td>
          <td>(</td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task for a given number of milliseconds.</p>
<p >This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use task_delay_until().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4341b580544831eea11b840cf068587b" name="a4341b580544831eea11b840cf068587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4341b580544831eea11b840cf068587b">&#9670;&#160;</a></span>delay() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay </td>
          <td>(</td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task for a given number of milliseconds.</p>
<p >This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use task_delay_until().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4341b580544831eea11b840cf068587b" name="a4341b580544831eea11b840cf068587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4341b580544831eea11b840cf068587b">&#9670;&#160;</a></span>delay() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay </td>
          <td>(</td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task for a given number of milliseconds.</p>
<p >This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use task_delay_until().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4341b580544831eea11b840cf068587b" name="a4341b580544831eea11b840cf068587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4341b580544831eea11b840cf068587b">&#9670;&#160;</a></span>delay() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay </td>
          <td>(</td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task for a given number of milliseconds.</p>
<p >This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use task_delay_until().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4341b580544831eea11b840cf068587b" name="a4341b580544831eea11b840cf068587b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4341b580544831eea11b840cf068587b">&#9670;&#160;</a></span>delay() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay </td>
          <td>(</td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task for a given number of milliseconds.</p>
<p >This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested. To delay cyclically, use task_delay_until().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa038d0eeb973ce7fca8689fa5bb91fec" name="aa038d0eeb973ce7fca8689fa5bb91fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa038d0eeb973ce7fca8689fa5bb91fec">&#9670;&#160;</a></span>delay_until() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay_until </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t *const&#160;</td>
          <td class="paramname"><em>prev_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p >The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_time</td><td>A pointer to the location storing the setpoint time. This should typically be initialized to the return value from pros::millis(). </td></tr>
    <tr><td class="paramname">delta</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa038d0eeb973ce7fca8689fa5bb91fec" name="aa038d0eeb973ce7fca8689fa5bb91fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa038d0eeb973ce7fca8689fa5bb91fec">&#9670;&#160;</a></span>delay_until() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay_until </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t *const&#160;</td>
          <td class="paramname"><em>prev_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p >The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_time</td><td>A pointer to the location storing the setpoint time. This should typically be initialized to the return value from pros::millis(). </td></tr>
    <tr><td class="paramname">delta</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa038d0eeb973ce7fca8689fa5bb91fec" name="aa038d0eeb973ce7fca8689fa5bb91fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa038d0eeb973ce7fca8689fa5bb91fec">&#9670;&#160;</a></span>delay_until() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay_until </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t *const&#160;</td>
          <td class="paramname"><em>prev_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p >The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_time</td><td>A pointer to the location storing the setpoint time. This should typically be initialized to the return value from pros::millis(). </td></tr>
    <tr><td class="paramname">delta</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa038d0eeb973ce7fca8689fa5bb91fec" name="aa038d0eeb973ce7fca8689fa5bb91fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa038d0eeb973ce7fca8689fa5bb91fec">&#9670;&#160;</a></span>delay_until() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay_until </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t *const&#160;</td>
          <td class="paramname"><em>prev_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p >The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_time</td><td>A pointer to the location storing the setpoint time. This should typically be initialized to the return value from pros::millis(). </td></tr>
    <tr><td class="paramname">delta</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa038d0eeb973ce7fca8689fa5bb91fec" name="aa038d0eeb973ce7fca8689fa5bb91fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa038d0eeb973ce7fca8689fa5bb91fec">&#9670;&#160;</a></span>delay_until() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pros::Task::delay_until </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t *const&#160;</td>
          <td class="paramname"><em>prev_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Delays a task until a specified time. This function can be used by periodic tasks to ensure a constant execution frequency.</p>
<p >The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prev_time</td><td>A pointer to the location storing the setpoint time. This should typically be initialized to the return value from pros::millis(). </td></tr>
    <tr><td class="paramname">delta</td><td>The number of milliseconds to wait (1000 milliseconds per second) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace43489ca71bdd884e4518700a4bbe58" name="ace43489ca71bdd884e4518700a4bbe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace43489ca71bdd884e4518700a4bbe58">&#9670;&#160;</a></span>get_count() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks. A task that has been deleted, but not yet reaped by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of tasks that are currently being managed by the kernel. </dd></dl>

</div>
</div>
<a id="ace43489ca71bdd884e4518700a4bbe58" name="ace43489ca71bdd884e4518700a4bbe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace43489ca71bdd884e4518700a4bbe58">&#9670;&#160;</a></span>get_count() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks. A task that has been deleted, but not yet reaped by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of tasks that are currently being managed by the kernel. </dd></dl>

</div>
</div>
<a id="ace43489ca71bdd884e4518700a4bbe58" name="ace43489ca71bdd884e4518700a4bbe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace43489ca71bdd884e4518700a4bbe58">&#9670;&#160;</a></span>get_count() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks. A task that has been deleted, but not yet reaped by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of tasks that are currently being managed by the kernel. </dd></dl>

</div>
</div>
<a id="ace43489ca71bdd884e4518700a4bbe58" name="ace43489ca71bdd884e4518700a4bbe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace43489ca71bdd884e4518700a4bbe58">&#9670;&#160;</a></span>get_count() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks. A task that has been deleted, but not yet reaped by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of tasks that are currently being managed by the kernel. </dd></dl>

</div>
</div>
<a id="ace43489ca71bdd884e4518700a4bbe58" name="ace43489ca71bdd884e4518700a4bbe58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace43489ca71bdd884e4518700a4bbe58">&#9670;&#160;</a></span>get_count() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::get_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks. A task that has been deleted, but not yet reaped by the idle task will also be included in the count. Tasks recently created may take one context switch to be counted.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of tasks that are currently being managed by the kernel. </dd></dl>

</div>
</div>
<a id="aa8521f655ff019d11caddb513afbb50e" name="aa8521f655ff019d11caddb513afbb50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8521f655ff019d11caddb513afbb50e">&#9670;&#160;</a></span>get_name() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pros::Task::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the name of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the name of the task </dd></dl>

</div>
</div>
<a id="aa8521f655ff019d11caddb513afbb50e" name="aa8521f655ff019d11caddb513afbb50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8521f655ff019d11caddb513afbb50e">&#9670;&#160;</a></span>get_name() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pros::Task::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the name of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the name of the task </dd></dl>

</div>
</div>
<a id="aa8521f655ff019d11caddb513afbb50e" name="aa8521f655ff019d11caddb513afbb50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8521f655ff019d11caddb513afbb50e">&#9670;&#160;</a></span>get_name() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pros::Task::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the name of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the name of the task </dd></dl>

</div>
</div>
<a id="aa8521f655ff019d11caddb513afbb50e" name="aa8521f655ff019d11caddb513afbb50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8521f655ff019d11caddb513afbb50e">&#9670;&#160;</a></span>get_name() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pros::Task::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the name of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the name of the task </dd></dl>

</div>
</div>
<a id="aa8521f655ff019d11caddb513afbb50e" name="aa8521f655ff019d11caddb513afbb50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8521f655ff019d11caddb513afbb50e">&#9670;&#160;</a></span>get_name() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pros::Task::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the name of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the name of the task </dd></dl>

</div>
</div>
<a id="a2a9dc12bb0799f8b18333ebcd7571e5b" name="a2a9dc12bb0799f8b18333ebcd7571e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9dc12bb0799f8b18333ebcd7571e5b">&#9670;&#160;</a></span>get_priority() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the priority of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the task </dd></dl>

</div>
</div>
<a id="a2a9dc12bb0799f8b18333ebcd7571e5b" name="a2a9dc12bb0799f8b18333ebcd7571e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9dc12bb0799f8b18333ebcd7571e5b">&#9670;&#160;</a></span>get_priority() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the priority of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the task </dd></dl>

</div>
</div>
<a id="a2a9dc12bb0799f8b18333ebcd7571e5b" name="a2a9dc12bb0799f8b18333ebcd7571e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9dc12bb0799f8b18333ebcd7571e5b">&#9670;&#160;</a></span>get_priority() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the priority of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the task </dd></dl>

</div>
</div>
<a id="a2a9dc12bb0799f8b18333ebcd7571e5b" name="a2a9dc12bb0799f8b18333ebcd7571e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9dc12bb0799f8b18333ebcd7571e5b">&#9670;&#160;</a></span>get_priority() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the priority of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the task </dd></dl>

</div>
</div>
<a id="a2a9dc12bb0799f8b18333ebcd7571e5b" name="a2a9dc12bb0799f8b18333ebcd7571e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9dc12bb0799f8b18333ebcd7571e5b">&#9670;&#160;</a></span>get_priority() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the priority of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The priority of the task </dd></dl>

</div>
</div>
<a id="a0e1c154b709095c4884d325d79a839e3" name="a0e1c154b709095c4884d325d79a839e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c154b709095c4884d325d79a839e3">&#9670;&#160;</a></span>get_state() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the state of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of the task </dd></dl>

</div>
</div>
<a id="a0e1c154b709095c4884d325d79a839e3" name="a0e1c154b709095c4884d325d79a839e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c154b709095c4884d325d79a839e3">&#9670;&#160;</a></span>get_state() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the state of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of the task </dd></dl>

</div>
</div>
<a id="a0e1c154b709095c4884d325d79a839e3" name="a0e1c154b709095c4884d325d79a839e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c154b709095c4884d325d79a839e3">&#9670;&#160;</a></span>get_state() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the state of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of the task </dd></dl>

</div>
</div>
<a id="a0e1c154b709095c4884d325d79a839e3" name="a0e1c154b709095c4884d325d79a839e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c154b709095c4884d325d79a839e3">&#9670;&#160;</a></span>get_state() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the state of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of the task </dd></dl>

</div>
</div>
<a id="a0e1c154b709095c4884d325d79a839e3" name="a0e1c154b709095c4884d325d79a839e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1c154b709095c4884d325d79a839e3">&#9670;&#160;</a></span>get_state() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::get_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the state of the specified task.</p>
<dl class="section return"><dt>Returns</dt><dd>The state of the task </dd></dl>

</div>
</div>
<a id="af250c6e369dd2621a8b31d7ed085f819" name="af250c6e369dd2621a8b31d7ed085f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af250c6e369dd2621a8b31d7ed085f819">&#9670;&#160;</a></span>join() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program. Analogous to std::thread::join in C++.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af250c6e369dd2621a8b31d7ed085f819" name="af250c6e369dd2621a8b31d7ed085f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af250c6e369dd2621a8b31d7ed085f819">&#9670;&#160;</a></span>join() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program. Analogous to std::thread::join in C++.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af250c6e369dd2621a8b31d7ed085f819" name="af250c6e369dd2621a8b31d7ed085f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af250c6e369dd2621a8b31d7ed085f819">&#9670;&#160;</a></span>join() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program. Analogous to std::thread::join in C++.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af250c6e369dd2621a8b31d7ed085f819" name="af250c6e369dd2621a8b31d7ed085f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af250c6e369dd2621a8b31d7ed085f819">&#9670;&#160;</a></span>join() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program. Analogous to std::thread::join in C++.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af250c6e369dd2621a8b31d7ed085f819" name="af250c6e369dd2621a8b31d7ed085f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af250c6e369dd2621a8b31d7ed085f819">&#9670;&#160;</a></span>join() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program. Analogous to std::thread::join in C++.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="af7ce264851745a555bb141884a1a61ab" name="af7ce264851745a555bb141884a1a61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce264851745a555bb141884a1a61ab">&#9670;&#160;</a></span>notify() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a simple notification to task and increments the notification counter.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a id="af7ce264851745a555bb141884a1a61ab" name="af7ce264851745a555bb141884a1a61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce264851745a555bb141884a1a61ab">&#9670;&#160;</a></span>notify() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a simple notification to task and increments the notification counter.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a id="af7ce264851745a555bb141884a1a61ab" name="af7ce264851745a555bb141884a1a61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce264851745a555bb141884a1a61ab">&#9670;&#160;</a></span>notify() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a simple notification to task and increments the notification counter.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a id="af7ce264851745a555bb141884a1a61ab" name="af7ce264851745a555bb141884a1a61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce264851745a555bb141884a1a61ab">&#9670;&#160;</a></span>notify() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a simple notification to task and increments the notification counter.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a id="af7ce264851745a555bb141884a1a61ab" name="af7ce264851745a555bb141884a1a61ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce264851745a555bb141884a1a61ab">&#9670;&#160;</a></span>notify() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a simple notification to task and increments the notification counter.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>Always returns true. </dd></dl>

</div>
</div>
<a id="a69c4d78a733f65cff31d7ab19d3f42f5" name="a69c4d78a733f65cff31d7ab19d3f42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4d78a733f65cff31d7ab19d3f42f5">&#9670;&#160;</a></span>notify_clear() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pros::Task::notify_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the notification for a task.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>False if there was not a notification waiting, true if there was </dd></dl>

</div>
</div>
<a id="a69c4d78a733f65cff31d7ab19d3f42f5" name="a69c4d78a733f65cff31d7ab19d3f42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4d78a733f65cff31d7ab19d3f42f5">&#9670;&#160;</a></span>notify_clear() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pros::Task::notify_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the notification for a task.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>False if there was not a notification waiting, true if there was </dd></dl>

</div>
</div>
<a id="a69c4d78a733f65cff31d7ab19d3f42f5" name="a69c4d78a733f65cff31d7ab19d3f42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4d78a733f65cff31d7ab19d3f42f5">&#9670;&#160;</a></span>notify_clear() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pros::Task::notify_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the notification for a task.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>False if there was not a notification waiting, true if there was </dd></dl>

</div>
</div>
<a id="a69c4d78a733f65cff31d7ab19d3f42f5" name="a69c4d78a733f65cff31d7ab19d3f42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4d78a733f65cff31d7ab19d3f42f5">&#9670;&#160;</a></span>notify_clear() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pros::Task::notify_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the notification for a task.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>False if there was not a notification waiting, true if there was </dd></dl>

</div>
</div>
<a id="a69c4d78a733f65cff31d7ab19d3f42f5" name="a69c4d78a733f65cff31d7ab19d3f42f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4d78a733f65cff31d7ab19d3f42f5">&#9670;&#160;</a></span>notify_clear() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pros::Task::notify_clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clears the notification for a task.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>False if there was not a notification waiting, true if there was </dd></dl>

</div>
</div>
<a id="add5bc6272aaa903fdf8ae6656d8ffddb" name="add5bc6272aaa903fdf8ae6656d8ffddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5bc6272aaa903fdf8ae6656d8ffddb">&#9670;&#160;</a></span>notify_ext() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify_ext </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">notify_action_e_t&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>prev_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a notification to a task, optionally performing some action. Will also retrieve the value of the notification in the target task before modifying the notification value.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value used in performing the action </td></tr>
    <tr><td class="paramname">action</td><td>An action to optionally perform on the receiving task's notification value </td></tr>
    <tr><td class="paramname">prev_value</td><td>A pointer to store the previous value of the target task's notification, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dependent on the notification action. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise. For all other NOTIFY_ACTION values: always return 0 </dd></dl>

</div>
</div>
<a id="add5bc6272aaa903fdf8ae6656d8ffddb" name="add5bc6272aaa903fdf8ae6656d8ffddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5bc6272aaa903fdf8ae6656d8ffddb">&#9670;&#160;</a></span>notify_ext() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify_ext </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">notify_action_e_t&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>prev_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a notification to a task, optionally performing some action. Will also retrieve the value of the notification in the target task before modifying the notification value.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value used in performing the action </td></tr>
    <tr><td class="paramname">action</td><td>An action to optionally perform on the receiving task's notification value </td></tr>
    <tr><td class="paramname">prev_value</td><td>A pointer to store the previous value of the target task's notification, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dependent on the notification action. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise. For all other NOTIFY_ACTION values: always return 0 </dd></dl>

</div>
</div>
<a id="add5bc6272aaa903fdf8ae6656d8ffddb" name="add5bc6272aaa903fdf8ae6656d8ffddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5bc6272aaa903fdf8ae6656d8ffddb">&#9670;&#160;</a></span>notify_ext() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify_ext </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">notify_action_e_t&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>prev_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a notification to a task, optionally performing some action. Will also retrieve the value of the notification in the target task before modifying the notification value.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value used in performing the action </td></tr>
    <tr><td class="paramname">action</td><td>An action to optionally perform on the receiving task's notification value </td></tr>
    <tr><td class="paramname">prev_value</td><td>A pointer to store the previous value of the target task's notification, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dependent on the notification action. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise. For all other NOTIFY_ACTION values: always return 0 </dd></dl>

</div>
</div>
<a id="add5bc6272aaa903fdf8ae6656d8ffddb" name="add5bc6272aaa903fdf8ae6656d8ffddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5bc6272aaa903fdf8ae6656d8ffddb">&#9670;&#160;</a></span>notify_ext() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify_ext </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">notify_action_e_t&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>prev_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a notification to a task, optionally performing some action. Will also retrieve the value of the notification in the target task before modifying the notification value.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value used in performing the action </td></tr>
    <tr><td class="paramname">action</td><td>An action to optionally perform on the receiving task's notification value </td></tr>
    <tr><td class="paramname">prev_value</td><td>A pointer to store the previous value of the target task's notification, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dependent on the notification action. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise. For all other NOTIFY_ACTION values: always return 0 </dd></dl>

</div>
</div>
<a id="add5bc6272aaa903fdf8ae6656d8ffddb" name="add5bc6272aaa903fdf8ae6656d8ffddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5bc6272aaa903fdf8ae6656d8ffddb">&#9670;&#160;</a></span>notify_ext() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t pros::Task::notify_ext </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">notify_action_e_t&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t *&#160;</td>
          <td class="paramname"><em>prev_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sends a notification to a task, optionally performing some action. Will also retrieve the value of the notification in the target task before modifying the notification value.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value used in performing the action </td></tr>
    <tr><td class="paramname">action</td><td>An action to optionally perform on the receiving task's notification value </td></tr>
    <tr><td class="paramname">prev_value</td><td>A pointer to store the previous value of the target task's notification, may be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dependent on the notification action. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise. For all other NOTIFY_ACTION values: always return 0 </dd></dl>

</div>
</div>
<a id="a7a7d29a221c08cda730ca9eb8c026a12" name="a7a7d29a221c08cda730ca9eb8c026a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d29a221c08cda730ca9eb8c026a12">&#9670;&#160;</a></span>notify_take() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::notify_take </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_on_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Waits for a notification to be nonzero.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_exit</td><td>If true (1), then the notification value is cleared. If false (0), then the notification value is decremented. </td></tr>
    <tr><td class="paramname">timeout</td><td>Specifies the amount of time to be spent waiting for a notification to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="a7a7d29a221c08cda730ca9eb8c026a12" name="a7a7d29a221c08cda730ca9eb8c026a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d29a221c08cda730ca9eb8c026a12">&#9670;&#160;</a></span>notify_take() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::notify_take </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_on_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Waits for a notification to be nonzero.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_exit</td><td>If true (1), then the notification value is cleared. If false (0), then the notification value is decremented. </td></tr>
    <tr><td class="paramname">timeout</td><td>Specifies the amount of time to be spent waiting for a notification to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="a7a7d29a221c08cda730ca9eb8c026a12" name="a7a7d29a221c08cda730ca9eb8c026a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d29a221c08cda730ca9eb8c026a12">&#9670;&#160;</a></span>notify_take() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::notify_take </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_on_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Waits for a notification to be nonzero.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_exit</td><td>If true (1), then the notification value is cleared. If false (0), then the notification value is decremented. </td></tr>
    <tr><td class="paramname">timeout</td><td>Specifies the amount of time to be spent waiting for a notification to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="a7a7d29a221c08cda730ca9eb8c026a12" name="a7a7d29a221c08cda730ca9eb8c026a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d29a221c08cda730ca9eb8c026a12">&#9670;&#160;</a></span>notify_take() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::notify_take </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_on_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Waits for a notification to be nonzero.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_exit</td><td>If true (1), then the notification value is cleared. If false (0), then the notification value is decremented. </td></tr>
    <tr><td class="paramname">timeout</td><td>Specifies the amount of time to be spent waiting for a notification to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="a7a7d29a221c08cda730ca9eb8c026a12" name="a7a7d29a221c08cda730ca9eb8c026a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d29a221c08cda730ca9eb8c026a12">&#9670;&#160;</a></span>notify_take() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint32_t pros::Task::notify_take </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_on_exit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Waits for a notification to be nonzero.</p>
<p >See <a href="https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html">https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_on_exit</td><td>If true (1), then the notification value is cleared. If false (0), then the notification value is decremented. </td></tr>
    <tr><td class="paramname">timeout</td><td>Specifies the amount of time to be spent waiting for a notification to occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the task's notification value before it is decremented or cleared </dd></dl>

</div>
</div>
<a id="a16c15efcec74a76b6848fc999ff0c232" name="a16c15efcec74a76b6848fc999ff0c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c15efcec74a76b6848fc999ff0c232">&#9670;&#160;</a></span>operator task_t() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::operator task_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert this object to a C task_t handle </p>

</div>
</div>
<a id="a16c15efcec74a76b6848fc999ff0c232" name="a16c15efcec74a76b6848fc999ff0c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c15efcec74a76b6848fc999ff0c232">&#9670;&#160;</a></span>operator task_t() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::operator task_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert this object to a C task_t handle </p>

</div>
</div>
<a id="a16c15efcec74a76b6848fc999ff0c232" name="a16c15efcec74a76b6848fc999ff0c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c15efcec74a76b6848fc999ff0c232">&#9670;&#160;</a></span>operator task_t() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::operator task_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert this object to a C task_t handle </p>

</div>
</div>
<a id="a16c15efcec74a76b6848fc999ff0c232" name="a16c15efcec74a76b6848fc999ff0c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c15efcec74a76b6848fc999ff0c232">&#9670;&#160;</a></span>operator task_t() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::operator task_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert this object to a C task_t handle </p>

</div>
</div>
<a id="a16c15efcec74a76b6848fc999ff0c232" name="a16c15efcec74a76b6848fc999ff0c232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c15efcec74a76b6848fc999ff0c232">&#9670;&#160;</a></span>operator task_t() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Task::operator task_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Convert this object to a C task_t handle </p>

</div>
</div>
<a id="a95e70532f42a21702d925c95d7432590" name="a95e70532f42a21702d925c95d7432590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e70532f42a21702d925c95d7432590">&#9670;&#160;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpros_1_1_task.html">Task</a> &amp; pros::Task::operator= </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95e70532f42a21702d925c95d7432590" name="a95e70532f42a21702d925c95d7432590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e70532f42a21702d925c95d7432590">&#9670;&#160;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpros_1_1_task.html">Task</a> &amp; pros::Task::operator= </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95e70532f42a21702d925c95d7432590" name="a95e70532f42a21702d925c95d7432590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e70532f42a21702d925c95d7432590">&#9670;&#160;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpros_1_1_task.html">Task</a> &amp; pros::Task::operator= </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95e70532f42a21702d925c95d7432590" name="a95e70532f42a21702d925c95d7432590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e70532f42a21702d925c95d7432590">&#9670;&#160;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpros_1_1_task.html">Task</a> &amp; pros::Task::operator= </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95e70532f42a21702d925c95d7432590" name="a95e70532f42a21702d925c95d7432590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e70532f42a21702d925c95d7432590">&#9670;&#160;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpros_1_1_task.html">Task</a> &amp; pros::Task::operator= </td>
          <td>(</td>
          <td class="paramtype">task_t&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new task and add it to the list of tasks that are ready to run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>A task handle from task_create() for which to create a <a class="el" href="classpros_1_1_task.html">pros::Task</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45269807dfc87bb1d5e9580346793e9d" name="a45269807dfc87bb1d5e9580346793e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45269807dfc87bb1d5e9580346793e9d">&#9670;&#160;</a></span>remove() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the <a class="el" href="classpros_1_1_task.html">Task</a> from the RTOS real time kernel's management. This task will be removed from all ready, blocked, suspended and event lists.</p>
<p >Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted. </p>

</div>
</div>
<a id="a45269807dfc87bb1d5e9580346793e9d" name="a45269807dfc87bb1d5e9580346793e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45269807dfc87bb1d5e9580346793e9d">&#9670;&#160;</a></span>remove() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the <a class="el" href="classpros_1_1_task.html">Task</a> from the RTOS real time kernel's management. This task will be removed from all ready, blocked, suspended and event lists.</p>
<p >Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted. </p>

</div>
</div>
<a id="a45269807dfc87bb1d5e9580346793e9d" name="a45269807dfc87bb1d5e9580346793e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45269807dfc87bb1d5e9580346793e9d">&#9670;&#160;</a></span>remove() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the <a class="el" href="classpros_1_1_task.html">Task</a> from the RTOS real time kernel's management. This task will be removed from all ready, blocked, suspended and event lists.</p>
<p >Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted. </p>

</div>
</div>
<a id="a45269807dfc87bb1d5e9580346793e9d" name="a45269807dfc87bb1d5e9580346793e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45269807dfc87bb1d5e9580346793e9d">&#9670;&#160;</a></span>remove() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the <a class="el" href="classpros_1_1_task.html">Task</a> from the RTOS real time kernel's management. This task will be removed from all ready, blocked, suspended and event lists.</p>
<p >Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted. </p>

</div>
</div>
<a id="a45269807dfc87bb1d5e9580346793e9d" name="a45269807dfc87bb1d5e9580346793e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45269807dfc87bb1d5e9580346793e9d">&#9670;&#160;</a></span>remove() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes the <a class="el" href="classpros_1_1_task.html">Task</a> from the RTOS real time kernel's management. This task will be removed from all ready, blocked, suspended and event lists.</p>
<p >Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted. </p>

</div>
</div>
<a id="abb8b8aa01d13ba3992953d0a7d668a47" name="abb8b8aa01d13ba3992953d0a7d668a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b8aa01d13ba3992953d0a7d668a47">&#9670;&#160;</a></span>resume() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resumes the specified task, making it eligible to be scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8b8aa01d13ba3992953d0a7d668a47" name="abb8b8aa01d13ba3992953d0a7d668a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b8aa01d13ba3992953d0a7d668a47">&#9670;&#160;</a></span>resume() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resumes the specified task, making it eligible to be scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8b8aa01d13ba3992953d0a7d668a47" name="abb8b8aa01d13ba3992953d0a7d668a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b8aa01d13ba3992953d0a7d668a47">&#9670;&#160;</a></span>resume() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resumes the specified task, making it eligible to be scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8b8aa01d13ba3992953d0a7d668a47" name="abb8b8aa01d13ba3992953d0a7d668a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b8aa01d13ba3992953d0a7d668a47">&#9670;&#160;</a></span>resume() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resumes the specified task, making it eligible to be scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb8b8aa01d13ba3992953d0a7d668a47" name="abb8b8aa01d13ba3992953d0a7d668a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8b8aa01d13ba3992953d0a7d668a47">&#9670;&#160;</a></span>resume() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Resumes the specified task, making it eligible to be scheduled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to resume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205a9937d34311ba10f540bc58d0b0b9" name="a205a9937d34311ba10f540bc58d0b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a9937d34311ba10f540bc58d0b0b9">&#9670;&#160;</a></span>set_priority() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::set_priority </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the priority of the specified task.</p>
<p >If the specified task's state is available to be scheduled (e.g. not blocked) and new priority is higher than the currently running task, a context switch may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>The new priority of the task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205a9937d34311ba10f540bc58d0b0b9" name="a205a9937d34311ba10f540bc58d0b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a9937d34311ba10f540bc58d0b0b9">&#9670;&#160;</a></span>set_priority() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::set_priority </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the priority of the specified task.</p>
<p >If the specified task's state is available to be scheduled (e.g. not blocked) and new priority is higher than the currently running task, a context switch may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>The new priority of the task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205a9937d34311ba10f540bc58d0b0b9" name="a205a9937d34311ba10f540bc58d0b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a9937d34311ba10f540bc58d0b0b9">&#9670;&#160;</a></span>set_priority() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::set_priority </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the priority of the specified task.</p>
<p >If the specified task's state is available to be scheduled (e.g. not blocked) and new priority is higher than the currently running task, a context switch may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>The new priority of the task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205a9937d34311ba10f540bc58d0b0b9" name="a205a9937d34311ba10f540bc58d0b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a9937d34311ba10f540bc58d0b0b9">&#9670;&#160;</a></span>set_priority() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::set_priority </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the priority of the specified task.</p>
<p >If the specified task's state is available to be scheduled (e.g. not blocked) and new priority is higher than the currently running task, a context switch may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>The new priority of the task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a205a9937d34311ba10f540bc58d0b0b9" name="a205a9937d34311ba10f540bc58d0b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a205a9937d34311ba10f540bc58d0b0b9">&#9670;&#160;</a></span>set_priority() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::set_priority </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the priority of the specified task.</p>
<p >If the specified task's state is available to be scheduled (e.g. not blocked) and new priority is higher than the currently running task, a context switch may occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>The new priority of the task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07d452a967a2bd839f6e819ff26ff052" name="a07d452a967a2bd839f6e819ff26ff052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d452a967a2bd839f6e819ff26ff052">&#9670;&#160;</a></span>suspend() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Suspends the specified task, making it ineligible to be scheduled. </p>

</div>
</div>
<a id="a07d452a967a2bd839f6e819ff26ff052" name="a07d452a967a2bd839f6e819ff26ff052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d452a967a2bd839f6e819ff26ff052">&#9670;&#160;</a></span>suspend() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Suspends the specified task, making it ineligible to be scheduled. </p>

</div>
</div>
<a id="a07d452a967a2bd839f6e819ff26ff052" name="a07d452a967a2bd839f6e819ff26ff052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d452a967a2bd839f6e819ff26ff052">&#9670;&#160;</a></span>suspend() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Suspends the specified task, making it ineligible to be scheduled. </p>

</div>
</div>
<a id="a07d452a967a2bd839f6e819ff26ff052" name="a07d452a967a2bd839f6e819ff26ff052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d452a967a2bd839f6e819ff26ff052">&#9670;&#160;</a></span>suspend() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Suspends the specified task, making it ineligible to be scheduled. </p>

</div>
</div>
<a id="a07d452a967a2bd839f6e819ff26ff052" name="a07d452a967a2bd839f6e819ff26ff052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d452a967a2bd839f6e819ff26ff052">&#9670;&#160;</a></span>suspend() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pros::Task::suspend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Suspends the specified task, making it ineligible to be scheduled. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Pros/Pros-7-13-22/include/pros/<a class="el" href="_pros-7-13-22_2include_2pros_2rtos_8hpp_source.html">rtos.hpp</a></li>
<li>Pros/Pros-7-9-22/include/pros/<a class="el" href="_pros-7-9-22_2include_2pros_2rtos_8hpp_source.html">rtos.hpp</a></li>
<li>Pros/test-3/include/pros/<a class="el" href="test-3_2include_2pros_2rtos_8hpp_source.html">rtos.hpp</a></li>
<li>Pros/test-5/include/pros/<a class="el" href="test-5_2include_2pros_2rtos_8hpp_source.html">rtos.hpp</a></li>
<li>Pros/test-6/include/pros/<a class="el" href="test-6_2include_2pros_2rtos_8hpp_source.html">rtos.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
