<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Robotics team coding repo: pros::Serial Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Robotics team coding repo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pros</b></li><li class="navelem"><a class="el" href="classpros_1_1_serial.html">Serial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpros_1_1_serial-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pros::Serial Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20b7c3c88af816af3078939b048dcf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a20b7c3c88af816af3078939b048dcf4b">Serial</a> (std::uint8_t port, std::int32_t baudrate)</td></tr>
<tr class="separator:a20b7c3c88af816af3078939b048dcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memItemLeft" align="right" valign="top"><a id="a32311eebb33cab5a52e0a8743d3bd9da" name="a32311eebb33cab5a52e0a8743d3bd9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Serial</b> (std::uint8_t port)</td></tr>
<tr class="separator:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6d804852e6689d6c92c6b2c439824"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#ab8c6d804852e6689d6c92c6b2c439824">set_baudrate</a> (std::int32_t baudrate) const</td></tr>
<tr class="separator:ab8c6d804852e6689d6c92c6b2c439824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a4d897c6f3f83636f4d4627ab02c10e76">flush</a> () const</td></tr>
<tr class="separator:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca502997319088ea71cf870fbbca7eb8"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#aca502997319088ea71cf870fbbca7eb8">get_read_avail</a> () const</td></tr>
<tr class="separator:aca502997319088ea71cf870fbbca7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a08daf4a3df3e3c4924d66d0b2eb91538">get_write_free</a> () const</td></tr>
<tr class="separator:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a74560cbf9ec7bc3f49cbf54aadb049a9">get_port</a> () const</td></tr>
<tr class="separator:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec51db5a7726f2220723971c1999881"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a5ec51db5a7726f2220723971c1999881">peek_byte</a> () const</td></tr>
<tr class="separator:a5ec51db5a7726f2220723971c1999881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c62f236867ec160668389a47d09a5e"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a59c62f236867ec160668389a47d09a5e">read_byte</a> () const</td></tr>
<tr class="separator:a59c62f236867ec160668389a47d09a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42f31fa7a5bd936010a346167c1946"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a0d42f31fa7a5bd936010a346167c1946">read</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a0d42f31fa7a5bd936010a346167c1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16477199d136d4f2ccbc73281d03965b"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a16477199d136d4f2ccbc73281d03965b">write_byte</a> (std::uint8_t buffer) const</td></tr>
<tr class="separator:a16477199d136d4f2ccbc73281d03965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865313d3b482d9ffdd380edc36273b24"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a865313d3b482d9ffdd380edc36273b24">write</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a865313d3b482d9ffdd380edc36273b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b7c3c88af816af3078939b048dcf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a20b7c3c88af816af3078939b048dcf4b">Serial</a> (std::uint8_t port, std::int32_t baudrate)</td></tr>
<tr class="separator:a20b7c3c88af816af3078939b048dcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memItemLeft" align="right" valign="top"><a id="a32311eebb33cab5a52e0a8743d3bd9da" name="a32311eebb33cab5a52e0a8743d3bd9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Serial</b> (std::uint8_t port)</td></tr>
<tr class="separator:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6d804852e6689d6c92c6b2c439824"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#ab8c6d804852e6689d6c92c6b2c439824">set_baudrate</a> (std::int32_t baudrate) const</td></tr>
<tr class="separator:ab8c6d804852e6689d6c92c6b2c439824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a4d897c6f3f83636f4d4627ab02c10e76">flush</a> () const</td></tr>
<tr class="separator:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca502997319088ea71cf870fbbca7eb8"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#aca502997319088ea71cf870fbbca7eb8">get_read_avail</a> () const</td></tr>
<tr class="separator:aca502997319088ea71cf870fbbca7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a08daf4a3df3e3c4924d66d0b2eb91538">get_write_free</a> () const</td></tr>
<tr class="separator:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a74560cbf9ec7bc3f49cbf54aadb049a9">get_port</a> () const</td></tr>
<tr class="separator:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec51db5a7726f2220723971c1999881"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a5ec51db5a7726f2220723971c1999881">peek_byte</a> () const</td></tr>
<tr class="separator:a5ec51db5a7726f2220723971c1999881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c62f236867ec160668389a47d09a5e"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a59c62f236867ec160668389a47d09a5e">read_byte</a> () const</td></tr>
<tr class="separator:a59c62f236867ec160668389a47d09a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42f31fa7a5bd936010a346167c1946"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a0d42f31fa7a5bd936010a346167c1946">read</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a0d42f31fa7a5bd936010a346167c1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16477199d136d4f2ccbc73281d03965b"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a16477199d136d4f2ccbc73281d03965b">write_byte</a> (std::uint8_t buffer) const</td></tr>
<tr class="separator:a16477199d136d4f2ccbc73281d03965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865313d3b482d9ffdd380edc36273b24"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a865313d3b482d9ffdd380edc36273b24">write</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a865313d3b482d9ffdd380edc36273b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b7c3c88af816af3078939b048dcf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a20b7c3c88af816af3078939b048dcf4b">Serial</a> (std::uint8_t port, std::int32_t baudrate)</td></tr>
<tr class="separator:a20b7c3c88af816af3078939b048dcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memItemLeft" align="right" valign="top"><a id="a32311eebb33cab5a52e0a8743d3bd9da" name="a32311eebb33cab5a52e0a8743d3bd9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Serial</b> (std::uint8_t port)</td></tr>
<tr class="separator:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6d804852e6689d6c92c6b2c439824"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#ab8c6d804852e6689d6c92c6b2c439824">set_baudrate</a> (std::int32_t baudrate) const</td></tr>
<tr class="separator:ab8c6d804852e6689d6c92c6b2c439824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a4d897c6f3f83636f4d4627ab02c10e76">flush</a> () const</td></tr>
<tr class="separator:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca502997319088ea71cf870fbbca7eb8"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#aca502997319088ea71cf870fbbca7eb8">get_read_avail</a> () const</td></tr>
<tr class="separator:aca502997319088ea71cf870fbbca7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a08daf4a3df3e3c4924d66d0b2eb91538">get_write_free</a> () const</td></tr>
<tr class="separator:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a74560cbf9ec7bc3f49cbf54aadb049a9">get_port</a> () const</td></tr>
<tr class="separator:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec51db5a7726f2220723971c1999881"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a5ec51db5a7726f2220723971c1999881">peek_byte</a> () const</td></tr>
<tr class="separator:a5ec51db5a7726f2220723971c1999881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c62f236867ec160668389a47d09a5e"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a59c62f236867ec160668389a47d09a5e">read_byte</a> () const</td></tr>
<tr class="separator:a59c62f236867ec160668389a47d09a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42f31fa7a5bd936010a346167c1946"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a0d42f31fa7a5bd936010a346167c1946">read</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a0d42f31fa7a5bd936010a346167c1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16477199d136d4f2ccbc73281d03965b"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a16477199d136d4f2ccbc73281d03965b">write_byte</a> (std::uint8_t buffer) const</td></tr>
<tr class="separator:a16477199d136d4f2ccbc73281d03965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865313d3b482d9ffdd380edc36273b24"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a865313d3b482d9ffdd380edc36273b24">write</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a865313d3b482d9ffdd380edc36273b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b7c3c88af816af3078939b048dcf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a20b7c3c88af816af3078939b048dcf4b">Serial</a> (std::uint8_t port, std::int32_t baudrate)</td></tr>
<tr class="separator:a20b7c3c88af816af3078939b048dcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memItemLeft" align="right" valign="top"><a id="a32311eebb33cab5a52e0a8743d3bd9da" name="a32311eebb33cab5a52e0a8743d3bd9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Serial</b> (std::uint8_t port)</td></tr>
<tr class="separator:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6d804852e6689d6c92c6b2c439824"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#ab8c6d804852e6689d6c92c6b2c439824">set_baudrate</a> (std::int32_t baudrate) const</td></tr>
<tr class="separator:ab8c6d804852e6689d6c92c6b2c439824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a4d897c6f3f83636f4d4627ab02c10e76">flush</a> () const</td></tr>
<tr class="separator:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca502997319088ea71cf870fbbca7eb8"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#aca502997319088ea71cf870fbbca7eb8">get_read_avail</a> () const</td></tr>
<tr class="separator:aca502997319088ea71cf870fbbca7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a08daf4a3df3e3c4924d66d0b2eb91538">get_write_free</a> () const</td></tr>
<tr class="separator:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a74560cbf9ec7bc3f49cbf54aadb049a9">get_port</a> () const</td></tr>
<tr class="separator:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec51db5a7726f2220723971c1999881"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a5ec51db5a7726f2220723971c1999881">peek_byte</a> () const</td></tr>
<tr class="separator:a5ec51db5a7726f2220723971c1999881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c62f236867ec160668389a47d09a5e"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a59c62f236867ec160668389a47d09a5e">read_byte</a> () const</td></tr>
<tr class="separator:a59c62f236867ec160668389a47d09a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42f31fa7a5bd936010a346167c1946"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a0d42f31fa7a5bd936010a346167c1946">read</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a0d42f31fa7a5bd936010a346167c1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16477199d136d4f2ccbc73281d03965b"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a16477199d136d4f2ccbc73281d03965b">write_byte</a> (std::uint8_t buffer) const</td></tr>
<tr class="separator:a16477199d136d4f2ccbc73281d03965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865313d3b482d9ffdd380edc36273b24"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a865313d3b482d9ffdd380edc36273b24">write</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a865313d3b482d9ffdd380edc36273b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b7c3c88af816af3078939b048dcf4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a20b7c3c88af816af3078939b048dcf4b">Serial</a> (std::uint8_t port, std::int32_t baudrate)</td></tr>
<tr class="separator:a20b7c3c88af816af3078939b048dcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memItemLeft" align="right" valign="top"><a id="a32311eebb33cab5a52e0a8743d3bd9da" name="a32311eebb33cab5a52e0a8743d3bd9da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Serial</b> (std::uint8_t port)</td></tr>
<tr class="separator:a32311eebb33cab5a52e0a8743d3bd9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6d804852e6689d6c92c6b2c439824"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#ab8c6d804852e6689d6c92c6b2c439824">set_baudrate</a> (std::int32_t baudrate) const</td></tr>
<tr class="separator:ab8c6d804852e6689d6c92c6b2c439824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a4d897c6f3f83636f4d4627ab02c10e76">flush</a> () const</td></tr>
<tr class="separator:a4d897c6f3f83636f4d4627ab02c10e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca502997319088ea71cf870fbbca7eb8"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#aca502997319088ea71cf870fbbca7eb8">get_read_avail</a> () const</td></tr>
<tr class="separator:aca502997319088ea71cf870fbbca7eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a08daf4a3df3e3c4924d66d0b2eb91538">get_write_free</a> () const</td></tr>
<tr class="separator:a08daf4a3df3e3c4924d66d0b2eb91538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a74560cbf9ec7bc3f49cbf54aadb049a9">get_port</a> () const</td></tr>
<tr class="separator:a74560cbf9ec7bc3f49cbf54aadb049a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec51db5a7726f2220723971c1999881"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a5ec51db5a7726f2220723971c1999881">peek_byte</a> () const</td></tr>
<tr class="separator:a5ec51db5a7726f2220723971c1999881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c62f236867ec160668389a47d09a5e"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a59c62f236867ec160668389a47d09a5e">read_byte</a> () const</td></tr>
<tr class="separator:a59c62f236867ec160668389a47d09a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d42f31fa7a5bd936010a346167c1946"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a0d42f31fa7a5bd936010a346167c1946">read</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a0d42f31fa7a5bd936010a346167c1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16477199d136d4f2ccbc73281d03965b"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a16477199d136d4f2ccbc73281d03965b">write_byte</a> (std::uint8_t buffer) const</td></tr>
<tr class="separator:a16477199d136d4f2ccbc73281d03965b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865313d3b482d9ffdd380edc36273b24"><td class="memItemLeft" align="right" valign="top">virtual std::int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpros_1_1_serial.html#a865313d3b482d9ffdd380edc36273b24">write</a> (std::uint8_t *buffer, std::int32_t length) const</td></tr>
<tr class="separator:a865313d3b482d9ffdd380edc36273b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a20b7c3c88af816af3078939b048dcf4b" name="a20b7c3c88af816af3078939b048dcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b7c3c88af816af3078939b048dcf4b">&#9670;&#160;</a></span>Serial() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Serial::Serial </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a <a class="el" href="classpros_1_1_serial.html">Serial</a> object for the given port and specifications.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The V5 port number from 1-21 </td></tr>
    <tr><td class="paramname">baudrate</td><td>The baudrate to run the port at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b7c3c88af816af3078939b048dcf4b" name="a20b7c3c88af816af3078939b048dcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b7c3c88af816af3078939b048dcf4b">&#9670;&#160;</a></span>Serial() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Serial::Serial </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a <a class="el" href="classpros_1_1_serial.html">Serial</a> object for the given port and specifications.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The V5 port number from 1-21 </td></tr>
    <tr><td class="paramname">baudrate</td><td>The baudrate to run the port at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b7c3c88af816af3078939b048dcf4b" name="a20b7c3c88af816af3078939b048dcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b7c3c88af816af3078939b048dcf4b">&#9670;&#160;</a></span>Serial() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Serial::Serial </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a <a class="el" href="classpros_1_1_serial.html">Serial</a> object for the given port and specifications.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The V5 port number from 1-21 </td></tr>
    <tr><td class="paramname">baudrate</td><td>The baudrate to run the port at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b7c3c88af816af3078939b048dcf4b" name="a20b7c3c88af816af3078939b048dcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b7c3c88af816af3078939b048dcf4b">&#9670;&#160;</a></span>Serial() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Serial::Serial </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a <a class="el" href="classpros_1_1_serial.html">Serial</a> object for the given port and specifications.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The V5 port number from 1-21 </td></tr>
    <tr><td class="paramname">baudrate</td><td>The baudrate to run the port at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b7c3c88af816af3078939b048dcf4b" name="a20b7c3c88af816af3078939b048dcf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b7c3c88af816af3078939b048dcf4b">&#9670;&#160;</a></span>Serial() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pros::Serial::Serial </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Creates a <a class="el" href="classpros_1_1_serial.html">Serial</a> object for the given port and specifications.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The V5 port number from 1-21 </td></tr>
    <tr><td class="paramname">baudrate</td><td>The baudrate to run the port at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d897c6f3f83636f4d4627ab02c10e76" name="a4d897c6f3f83636f4d4627ab02c10e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d897c6f3f83636f4d4627ab02c10e76">&#9670;&#160;</a></span>flush() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears the internal input and output FIFO buffers.</p>
<p >This can be useful to reset state and remove old, potentially unneeded data from the input FIFO buffer or to cancel sending any data in the output FIFO buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not cause the data in the output buffer to be written, it simply clears the internal buffers. Unlike stdout, generic serial does not use buffered IO (the FIFO buffers are written as soon as possible).</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a4d897c6f3f83636f4d4627ab02c10e76" name="a4d897c6f3f83636f4d4627ab02c10e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d897c6f3f83636f4d4627ab02c10e76">&#9670;&#160;</a></span>flush() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears the internal input and output FIFO buffers.</p>
<p >This can be useful to reset state and remove old, potentially unneeded data from the input FIFO buffer or to cancel sending any data in the output FIFO buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not cause the data in the output buffer to be written, it simply clears the internal buffers. Unlike stdout, generic serial does not use buffered IO (the FIFO buffers are written as soon as possible).</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a4d897c6f3f83636f4d4627ab02c10e76" name="a4d897c6f3f83636f4d4627ab02c10e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d897c6f3f83636f4d4627ab02c10e76">&#9670;&#160;</a></span>flush() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears the internal input and output FIFO buffers.</p>
<p >This can be useful to reset state and remove old, potentially unneeded data from the input FIFO buffer or to cancel sending any data in the output FIFO buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not cause the data in the output buffer to be written, it simply clears the internal buffers. Unlike stdout, generic serial does not use buffered IO (the FIFO buffers are written as soon as possible).</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a4d897c6f3f83636f4d4627ab02c10e76" name="a4d897c6f3f83636f4d4627ab02c10e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d897c6f3f83636f4d4627ab02c10e76">&#9670;&#160;</a></span>flush() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears the internal input and output FIFO buffers.</p>
<p >This can be useful to reset state and remove old, potentially unneeded data from the input FIFO buffer or to cancel sending any data in the output FIFO buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not cause the data in the output buffer to be written, it simply clears the internal buffers. Unlike stdout, generic serial does not use buffered IO (the FIFO buffers are written as soon as possible).</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a4d897c6f3f83636f4d4627ab02c10e76" name="a4d897c6f3f83636f4d4627ab02c10e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d897c6f3f83636f4d4627ab02c10e76">&#9670;&#160;</a></span>flush() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Clears the internal input and output FIFO buffers.</p>
<p >This can be useful to reset state and remove old, potentially unneeded data from the input FIFO buffer or to cancel sending any data in the output FIFO buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not cause the data in the output buffer to be written, it simply clears the internal buffers. Unlike stdout, generic serial does not use buffered IO (the FIFO buffers are written as soon as possible).</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a74560cbf9ec7bc3f49cbf54aadb049a9" name="a74560cbf9ec7bc3f49cbf54aadb049a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74560cbf9ec7bc3f49cbf54aadb049a9">&#9670;&#160;</a></span>get_port() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t pros::Serial::get_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the port number of the serial port.</p>
<dl class="section return"><dt>Returns</dt><dd>The serial port's port number. </dd></dl>

</div>
</div>
<a id="a74560cbf9ec7bc3f49cbf54aadb049a9" name="a74560cbf9ec7bc3f49cbf54aadb049a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74560cbf9ec7bc3f49cbf54aadb049a9">&#9670;&#160;</a></span>get_port() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t pros::Serial::get_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the port number of the serial port.</p>
<dl class="section return"><dt>Returns</dt><dd>The serial port's port number. </dd></dl>

</div>
</div>
<a id="a74560cbf9ec7bc3f49cbf54aadb049a9" name="a74560cbf9ec7bc3f49cbf54aadb049a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74560cbf9ec7bc3f49cbf54aadb049a9">&#9670;&#160;</a></span>get_port() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t pros::Serial::get_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the port number of the serial port.</p>
<dl class="section return"><dt>Returns</dt><dd>The serial port's port number. </dd></dl>

</div>
</div>
<a id="a74560cbf9ec7bc3f49cbf54aadb049a9" name="a74560cbf9ec7bc3f49cbf54aadb049a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74560cbf9ec7bc3f49cbf54aadb049a9">&#9670;&#160;</a></span>get_port() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t pros::Serial::get_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the port number of the serial port.</p>
<dl class="section return"><dt>Returns</dt><dd>The serial port's port number. </dd></dl>

</div>
</div>
<a id="a74560cbf9ec7bc3f49cbf54aadb049a9" name="a74560cbf9ec7bc3f49cbf54aadb049a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74560cbf9ec7bc3f49cbf54aadb049a9">&#9670;&#160;</a></span>get_port() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t pros::Serial::get_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Gets the port number of the serial port.</p>
<dl class="section return"><dt>Returns</dt><dd>The serial port's port number. </dd></dl>

</div>
</div>
<a id="aca502997319088ea71cf870fbbca7eb8" name="aca502997319088ea71cf870fbbca7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca502997319088ea71cf870fbbca7eb8">&#9670;&#160;</a></span>get_read_avail() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_read_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes available to be read in the the port's FIFO input buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually read any bytes, is simply returns the number of bytes available to be read.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes avaliable to be read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="aca502997319088ea71cf870fbbca7eb8" name="aca502997319088ea71cf870fbbca7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca502997319088ea71cf870fbbca7eb8">&#9670;&#160;</a></span>get_read_avail() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_read_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes available to be read in the the port's FIFO input buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually read any bytes, is simply returns the number of bytes available to be read.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes avaliable to be read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="aca502997319088ea71cf870fbbca7eb8" name="aca502997319088ea71cf870fbbca7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca502997319088ea71cf870fbbca7eb8">&#9670;&#160;</a></span>get_read_avail() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_read_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes available to be read in the the port's FIFO input buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually read any bytes, is simply returns the number of bytes available to be read.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes avaliable to be read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="aca502997319088ea71cf870fbbca7eb8" name="aca502997319088ea71cf870fbbca7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca502997319088ea71cf870fbbca7eb8">&#9670;&#160;</a></span>get_read_avail() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_read_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes available to be read in the the port's FIFO input buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually read any bytes, is simply returns the number of bytes available to be read.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes avaliable to be read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="aca502997319088ea71cf870fbbca7eb8" name="aca502997319088ea71cf870fbbca7eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca502997319088ea71cf870fbbca7eb8">&#9670;&#160;</a></span>get_read_avail() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_read_avail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes available to be read in the the port's FIFO input buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually read any bytes, is simply returns the number of bytes available to be read.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes avaliable to be read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a08daf4a3df3e3c4924d66d0b2eb91538" name="a08daf4a3df3e3c4924d66d0b2eb91538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08daf4a3df3e3c4924d66d0b2eb91538">&#9670;&#160;</a></span>get_write_free() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_write_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes free in the port's FIFO output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually write any bytes, is simply returns the number of bytes free in the port's buffer.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes free or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a08daf4a3df3e3c4924d66d0b2eb91538" name="a08daf4a3df3e3c4924d66d0b2eb91538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08daf4a3df3e3c4924d66d0b2eb91538">&#9670;&#160;</a></span>get_write_free() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_write_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes free in the port's FIFO output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually write any bytes, is simply returns the number of bytes free in the port's buffer.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes free or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a08daf4a3df3e3c4924d66d0b2eb91538" name="a08daf4a3df3e3c4924d66d0b2eb91538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08daf4a3df3e3c4924d66d0b2eb91538">&#9670;&#160;</a></span>get_write_free() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_write_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes free in the port's FIFO output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually write any bytes, is simply returns the number of bytes free in the port's buffer.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes free or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a08daf4a3df3e3c4924d66d0b2eb91538" name="a08daf4a3df3e3c4924d66d0b2eb91538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08daf4a3df3e3c4924d66d0b2eb91538">&#9670;&#160;</a></span>get_write_free() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_write_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes free in the port's FIFO output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually write any bytes, is simply returns the number of bytes free in the port's buffer.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes free or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a08daf4a3df3e3c4924d66d0b2eb91538" name="a08daf4a3df3e3c4924d66d0b2eb91538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08daf4a3df3e3c4924d66d0b2eb91538">&#9670;&#160;</a></span>get_write_free() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::get_write_free </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the number of bytes free in the port's FIFO output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not actually write any bytes, is simply returns the number of bytes free in the port's buffer.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes free or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a5ec51db5a7726f2220723971c1999881" name="a5ec51db5a7726f2220723971c1999881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec51db5a7726f2220723971c1999881">&#9670;&#160;</a></span>peek_byte() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::peek_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer without removing it.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a5ec51db5a7726f2220723971c1999881" name="a5ec51db5a7726f2220723971c1999881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec51db5a7726f2220723971c1999881">&#9670;&#160;</a></span>peek_byte() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::peek_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer without removing it.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a5ec51db5a7726f2220723971c1999881" name="a5ec51db5a7726f2220723971c1999881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec51db5a7726f2220723971c1999881">&#9670;&#160;</a></span>peek_byte() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::peek_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer without removing it.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a5ec51db5a7726f2220723971c1999881" name="a5ec51db5a7726f2220723971c1999881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec51db5a7726f2220723971c1999881">&#9670;&#160;</a></span>peek_byte() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::peek_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer without removing it.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a5ec51db5a7726f2220723971c1999881" name="a5ec51db5a7726f2220723971c1999881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec51db5a7726f2220723971c1999881">&#9670;&#160;</a></span>peek_byte() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::peek_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer without removing it.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a0d42f31fa7a5bd936010a346167c1946" name="a0d42f31fa7a5bd936010a346167c1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d42f31fa7a5bd936010a346167c1946">&#9670;&#160;</a></span>read() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads up to the next length bytes from the port's input buffer and places them in the user supplied buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only return bytes that are currently avaliable to be read and will not block waiting for any to arrive.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The location to place the data read </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a0d42f31fa7a5bd936010a346167c1946" name="a0d42f31fa7a5bd936010a346167c1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d42f31fa7a5bd936010a346167c1946">&#9670;&#160;</a></span>read() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads up to the next length bytes from the port's input buffer and places them in the user supplied buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only return bytes that are currently avaliable to be read and will not block waiting for any to arrive.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The location to place the data read </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a0d42f31fa7a5bd936010a346167c1946" name="a0d42f31fa7a5bd936010a346167c1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d42f31fa7a5bd936010a346167c1946">&#9670;&#160;</a></span>read() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads up to the next length bytes from the port's input buffer and places them in the user supplied buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only return bytes that are currently avaliable to be read and will not block waiting for any to arrive.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The location to place the data read </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a0d42f31fa7a5bd936010a346167c1946" name="a0d42f31fa7a5bd936010a346167c1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d42f31fa7a5bd936010a346167c1946">&#9670;&#160;</a></span>read() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads up to the next length bytes from the port's input buffer and places them in the user supplied buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only return bytes that are currently avaliable to be read and will not block waiting for any to arrive.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The location to place the data read </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a0d42f31fa7a5bd936010a346167c1946" name="a0d42f31fa7a5bd936010a346167c1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d42f31fa7a5bd936010a346167c1946">&#9670;&#160;</a></span>read() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads up to the next length bytes from the port's input buffer and places them in the user supplied buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function will only return bytes that are currently avaliable to be read and will not block waiting for any to arrive.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The location to place the data read </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a59c62f236867ec160668389a47d09a5e" name="a59c62f236867ec160668389a47d09a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c62f236867ec160668389a47d09a5e">&#9670;&#160;</a></span>read_byte() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a59c62f236867ec160668389a47d09a5e" name="a59c62f236867ec160668389a47d09a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c62f236867ec160668389a47d09a5e">&#9670;&#160;</a></span>read_byte() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a59c62f236867ec160668389a47d09a5e" name="a59c62f236867ec160668389a47d09a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c62f236867ec160668389a47d09a5e">&#9670;&#160;</a></span>read_byte() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a59c62f236867ec160668389a47d09a5e" name="a59c62f236867ec160668389a47d09a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c62f236867ec160668389a47d09a5e">&#9670;&#160;</a></span>read_byte() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a59c62f236867ec160668389a47d09a5e" name="a59c62f236867ec160668389a47d09a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c62f236867ec160668389a47d09a5e">&#9670;&#160;</a></span>read_byte() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::read_byte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Reads the next byte avaliable in the port's input buffer.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="section return"><dt>Returns</dt><dd>The next byte avaliable to be read, -1 if none are available, or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="ab8c6d804852e6689d6c92c6b2c439824" name="ab8c6d804852e6689d6c92c6b2c439824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6d804852e6689d6c92c6b2c439824">&#9670;&#160;</a></span>set_baudrate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classpros_1_1_serial.html">Serial</a> communication functions <br  />
 These functions allow programmers to communicate using UART over RS485 <br  />
 Sets the baudrate for the serial port to operate at.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate to operate at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="ab8c6d804852e6689d6c92c6b2c439824" name="ab8c6d804852e6689d6c92c6b2c439824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6d804852e6689d6c92c6b2c439824">&#9670;&#160;</a></span>set_baudrate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classpros_1_1_serial.html">Serial</a> communication functions <br  />
 These functions allow programmers to communicate using UART over RS485 <br  />
 Sets the baudrate for the serial port to operate at.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate to operate at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="ab8c6d804852e6689d6c92c6b2c439824" name="ab8c6d804852e6689d6c92c6b2c439824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6d804852e6689d6c92c6b2c439824">&#9670;&#160;</a></span>set_baudrate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classpros_1_1_serial.html">Serial</a> communication functions <br  />
 These functions allow programmers to communicate using UART over RS485 <br  />
 Sets the baudrate for the serial port to operate at.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate to operate at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="ab8c6d804852e6689d6c92c6b2c439824" name="ab8c6d804852e6689d6c92c6b2c439824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6d804852e6689d6c92c6b2c439824">&#9670;&#160;</a></span>set_baudrate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classpros_1_1_serial.html">Serial</a> communication functions <br  />
 These functions allow programmers to communicate using UART over RS485 <br  />
 Sets the baudrate for the serial port to operate at.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate to operate at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="ab8c6d804852e6689d6c92c6b2c439824" name="ab8c6d804852e6689d6c92c6b2c439824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6d804852e6689d6c92c6b2c439824">&#9670;&#160;</a></span>set_baudrate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::set_baudrate </td>
          <td>(</td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>baudrate</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classpros_1_1_serial.html">Serial</a> communication functions <br  />
 These functions allow programmers to communicate using UART over RS485 <br  />
 Sets the baudrate for the serial port to operate at.</p>
<p >This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baudrate</td><td>The baudrate to operate at</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the operation was successful or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a865313d3b482d9ffdd380edc36273b24" name="a865313d3b482d9ffdd380edc36273b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865313d3b482d9ffdd380edc36273b24">&#9670;&#160;</a></span>write() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Writes up to length bytes from the user supplied buffer to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data to write </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a865313d3b482d9ffdd380edc36273b24" name="a865313d3b482d9ffdd380edc36273b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865313d3b482d9ffdd380edc36273b24">&#9670;&#160;</a></span>write() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Writes up to length bytes from the user supplied buffer to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data to write </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a865313d3b482d9ffdd380edc36273b24" name="a865313d3b482d9ffdd380edc36273b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865313d3b482d9ffdd380edc36273b24">&#9670;&#160;</a></span>write() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Writes up to length bytes from the user supplied buffer to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data to write </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a865313d3b482d9ffdd380edc36273b24" name="a865313d3b482d9ffdd380edc36273b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865313d3b482d9ffdd380edc36273b24">&#9670;&#160;</a></span>write() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Writes up to length bytes from the user supplied buffer to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data to write </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a865313d3b482d9ffdd380edc36273b24" name="a865313d3b482d9ffdd380edc36273b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865313d3b482d9ffdd380edc36273b24">&#9670;&#160;</a></span>write() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Writes up to length bytes from the user supplied buffer to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The data to write </td></tr>
    <tr><td class="paramname">length</td><td>The maximum number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a16477199d136d4f2ccbc73281d03965b" name="a16477199d136d4f2ccbc73281d03965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16477199d136d4f2ccbc73281d03965b">&#9670;&#160;</a></span>write_byte() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write_byte </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Write the given byte to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The byte to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a16477199d136d4f2ccbc73281d03965b" name="a16477199d136d4f2ccbc73281d03965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16477199d136d4f2ccbc73281d03965b">&#9670;&#160;</a></span>write_byte() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write_byte </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Write the given byte to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The byte to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a16477199d136d4f2ccbc73281d03965b" name="a16477199d136d4f2ccbc73281d03965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16477199d136d4f2ccbc73281d03965b">&#9670;&#160;</a></span>write_byte() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write_byte </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Write the given byte to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The byte to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a16477199d136d4f2ccbc73281d03965b" name="a16477199d136d4f2ccbc73281d03965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16477199d136d4f2ccbc73281d03965b">&#9670;&#160;</a></span>write_byte() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write_byte </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Write the given byte to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The byte to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<a id="a16477199d136d4f2ccbc73281d03965b" name="a16477199d136d4f2ccbc73281d03965b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16477199d136d4f2ccbc73281d03965b">&#9670;&#160;</a></span>write_byte() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::int32_t pros::Serial::write_byte </td>
          <td>(</td>
          <td class="paramtype">std::uint8_t&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Write the given byte to the port's output buffer.</p>
<dl class="section note"><dt>Note</dt><dd>Data in the port's output buffer is written to the serial port as soon as possible on a FIFO basis and can not be done manually by the user.</dd></dl>
<p>This function uses the following values of errno when an error state is reached: EINVAL - The given value is not within the range of V5 ports (1-21). EACCES - Another resource is currently trying to access the port. EIO - Serious internal write error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The byte to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written or PROS_ERR if the operation failed, setting errno. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Pros/Pros-7-13-22/include/pros/<a class="el" href="_pros-7-13-22_2include_2pros_2serial_8hpp_source.html">serial.hpp</a></li>
<li>Pros/Pros-7-9-22/include/pros/<a class="el" href="_pros-7-9-22_2include_2pros_2serial_8hpp_source.html">serial.hpp</a></li>
<li>Pros/test-3/include/pros/<a class="el" href="test-3_2include_2pros_2serial_8hpp_source.html">serial.hpp</a></li>
<li>Pros/test-5/include/pros/<a class="el" href="test-5_2include_2pros_2serial_8hpp_source.html">serial.hpp</a></li>
<li>Pros/test-6/include/pros/<a class="el" href="test-6_2include_2pros_2serial_8hpp_source.html">serial.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
